<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>介绍 | Type Client Framework</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/TypeClient/assets/css/0.styles.ee4cc296.css" as="style"><link rel="preload" href="/TypeClient/assets/js/app.253fc704.js" as="script"><link rel="preload" href="/TypeClient/assets/js/2.86eb2bce.js" as="script"><link rel="preload" href="/TypeClient/assets/js/7.d976a72a.js" as="script"><link rel="prefetch" href="/TypeClient/assets/js/3.11572a76.js"><link rel="prefetch" href="/TypeClient/assets/js/4.3b6a7e49.js"><link rel="prefetch" href="/TypeClient/assets/js/5.7163d2a1.js"><link rel="prefetch" href="/TypeClient/assets/js/6.0b046750.js"><link rel="prefetch" href="/TypeClient/assets/js/8.09b1b58b.js">
    <link rel="stylesheet" href="/TypeClient/assets/css/0.styles.ee4cc296.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TypeClient/" class="home-link router-link-active"><!----> <span class="site-name">Type Client Framework</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TypeClient/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/TypeClient/zh/guide.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  介绍
</a></div><div class="nav-item"><a href="/TypeClient/zh/core.html" class="nav-link">
  核心
</a></div><div class="nav-item"><a href="/TypeClient/zh/react.html" class="nav-link">
  React
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TypeClient/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/TypeClient/zh/guide.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  介绍
</a></div><div class="nav-item"><a href="/TypeClient/zh/core.html" class="nav-link">
  核心
</a></div><div class="nav-item"><a href="/TypeClient/zh/react.html" class="nav-link">
  React
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>介绍</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TypeClient/zh/guide.html#设计理念" class="sidebar-link">设计理念</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/TypeClient/zh/guide.html#遇到的难点" class="sidebar-link">遇到的难点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#ioc设计中的自动绑定" class="sidebar-link">iOC设计中的自动绑定</a></li><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#通用响应式对象" class="sidebar-link">通用响应式对象</a></li><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#百万路由设计" class="sidebar-link">百万路由设计</a></li><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#component调用ioc服务" class="sidebar-link">Component调用iOC服务</a></li></ul></li><li><a href="/TypeClient/zh/guide.html#如何使用" class="sidebar-link">如何使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#模板化" class="sidebar-link">模板化</a></li><li class="sidebar-sub-header"><a href="/TypeClient/zh/guide.html#自定义" class="sidebar-link">自定义</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h1> <p>它是一套轻量级的前端微应用开发架构，能够在一个页面上同时运行多个应用。在技术栈的选择上，也没有强制性的定义，它可以通过编写驱动引擎来实现对各种渲染引擎的支持。</p> <p>它的孵化来源于艾耕科技的内部项目，针对路由复杂度高、代码管理混乱以及开发维护不方便的痛点上，我们提出了一种以后端服务开发理念为指引的前端微应用开发模式。它能够解决所有基于路由化的应用场景，并且提高路由匹配的速度，实现高性能路由分发。</p> <h2 id="设计理念"><a href="#设计理念" class="header-anchor">#</a> 设计理念</h2> <p>它的产生离不开对后端服务的理解。在后端开发的模型中，多个<code>client</code>应对单个<code>server</code>的模型给了我们很大灵感。在前端，无非就是单个<code>client</code>应对单个server的情况，那么我们就可以将后端的理念移植到前端。非常幸运的是，后端触发请求流转的事件也可以对应到前端，所以我们可以认为，用户的页面请求就是一个相对于后端的<code>request</code>请求。这样一来，前端理念已成。</p> <p>为了将请求处理逻辑解偶，我们采用了<code>AOP</code>和<code>iOC</code>理念来作为这个架构的基础设计，在代码层面上可以实现几乎类似JAVA注解的模式。再加上将前端各大框架作为渲染引擎，一个完整的架构设计就出来了。</p> <h2 id="遇到的难点"><a href="#遇到的难点" class="header-anchor">#</a> 遇到的难点</h2> <p>在架构设计之初，我们遇到了一些难点，经过好多个版本的迭代，最终成型。那么我们稍微讲解其中的难点与特殊设计以及技术方案的取舍。</p> <h3 id="ioc设计中的自动绑定"><a href="#ioc设计中的自动绑定" class="header-anchor">#</a> iOC设计中的自动绑定</h3> <p>我们采用了第三方开源的架构 <a href="https://www.npmjs.com/inversify" target="_blank" rel="noopener noreferrer">inversify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。如果根据这个架构的设计，我们需要不断的进行如下的代码编写：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">Container</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ServiceA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Container</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ServiceB<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Container</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>ServiceC<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toSelf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
</code></pre></div><p>如果我们模块多了，忘记绑定注入，那么也许会在调用某个服务的时候报错，提示找不到服务定义，而且每次绑定都是件非常累人的事情。那么为考虑如何将一来自动绑定呢？</p> <p>通过对<code>Controller</code>的设定作为入口，我们提供一个<code>useInject</code>方法。这个方法主要是在注解编写时候提供自动注入的能力。比如说：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token function-variable function">SomeAnnotation</span> <span class="token operator">=</span> <span class="token punctuation">(</span>classModules<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">useInject</span><span class="token punctuation">(</span>classModules<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们将<code>inversify:container</code>全局化，然后在<code>useInject</code>内部使用<code>Container.bind(classModules).toSelf()</code>方法来绑定。当然，我们还需要判断是否这个服务已经被绑定。当一切结束后，你会发现，我们根本不需要关心依赖如何绑定，只需要在什么时候调用就什么时候引用即可。</p> <h3 id="通用响应式对象"><a href="#通用响应式对象" class="header-anchor">#</a> 通用响应式对象</h3> <p>为了解决通用性数据响应的问题，我们考虑该如何将数据绑定起来，如何无缝实现数据对各大框架的兼容。就算是已经接入了各大框架，那么每个框架的响应原理不同，我们底层数据响应该如何去做？</p> <p>庆幸的是，随着vue3的出现，好像给我们提供了一个希望。我们考虑将 <a href="https://www.npmjs.com/@vue/reactivity" target="_blank" rel="noopener noreferrer">@vue/reactivity<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 作为底层数据响应，通过桥接方式对各大框架进行<code>forceUpdate</code>的任务调度。而在vue3内部则天然支持，无需做更多的调度。这样的方式浑然天成。不论是<code>react</code>或者<code>preact</code>都可以完美接受。</p> <p>只要是响应式框架，那么必定有任务调度机制，通过他们自身的任务调度，就一定可以结合vue3的reactivity特性对数据进行响应。</p> <p>在react中，我们采用</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> forUpdate<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>s <span class="token operator">=&gt;</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样的方式获取到<code>forceUpdate</code>函数进行响应。而<code>@vue/reactivity</code>中使用</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> effection <span class="token operator">=</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对响应数据的依赖进行收集后供<code>forceUpdate</code>来调度。这同时给react提供了一种非常便捷的数据修改方式，再也不需要使用<code>dispatch</code>来更新数据。唯一的缺点就是我们需要在<code>effect</code>函数中尽可能精确的收集依赖来保证数据的同步响应，特别是对数组的操作。</p> <h3 id="百万路由设计"><a href="#百万路由设计" class="header-anchor">#</a> 百万路由设计</h3> <p>前端路由一般性能不是瓶颈，但是在一些渲染架构上，比如<code>React</code>上，在量级非常大的组件下，DIFF就显得非常笨拙：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Route component<span class="token operator">=</span><span class="token punctuation">{</span>App<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;groups&quot;</span> components<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>main<span class="token operator">:</span> Groups<span class="token punctuation">,</span> sidebar<span class="token operator">:</span> GroupsSidebar<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;users&quot;</span> components<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>main<span class="token operator">:</span> Users<span class="token punctuation">,</span> sidebar<span class="token operator">:</span> UsersSidebar<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;users/:userId&quot;</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Profile<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">&gt;</span>
    <span class="token comment">// ... 10000个routers</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre></div><p>当匹配到的路由正巧命中最后一个，这时候<code>&lt;Route /&gt;</code>组件diff了正好10000个，相当于循环中需要匹配10000次，在不断更新的vDom上，它的性能是非常差的。</p> <p>当然有人会问实际业务场景中不可能存在如此之多的路由。是的，这确实不可能存在，但是对于性能的压榨前提下，我们需要更高性能的路由匹配模式。而<code>TypeClient</code>正好采用了高性能的字符串索引算法<a href="https://en.wikipedia.org/wiki/Radix_tree" target="_blank" rel="noopener noreferrer">radixtree<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来解决这个问题。</p> <h3 id="component调用ioc服务"><a href="#component调用ioc服务" class="header-anchor">#</a> Component调用iOC服务</h3> <p>一般的，在各大框架中，组件是独立的存在，但是我们基于iOC原则做服务功能的划分的时候，如何有效接入组件中使用，我们提出一个概念叫<code>iOCComponent</code>，这是一种新组件概念。</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">NewComponent</span> <span class="token punctuation">{</span>
  @<span class="token function">inject</span><span class="token punctuation">(</span>AnyService<span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">readonly</span> AnyService<span class="token operator">:</span> AnyService<span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>AnyService<span class="token punctuation">.</span><span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// return tsx</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然为来解决组件缓存问题，我们已经设计过这样的模式来获取</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> Cmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>NewComponent<span class="token punctuation">.</span>render<span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token keyword">return</span> <span class="token operator">&lt;</span>Cmp <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><h2 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h2> <p>框架使用具备一定的难度，上手成本较高，所以我们提供来模板供大家使用。</p> <h3 id="模板化"><a href="#模板化" class="header-anchor">#</a> 模板化</h3> <p>React端：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">git</span> clone git@github.com:flowxjs/TypeClientReactTemplate.git
$ <span class="token builtin class-name">cd</span> TypeClientReactTemplate
$ <span class="token function">npm</span> ci
$ <span class="token function">npm</span> start
</code></pre></div><blockquote><p>Vue3暂时不提供。需要等其正式发布后提供</p></blockquote> <h3 id="自定义"><a href="#自定义" class="header-anchor">#</a> 自定义</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">npm</span> i @typeclient/core
$ <span class="token function">npm</span> i @typeclient/react
</code></pre></div><blockquote><p>请参考后续讲解如何搭建自定义的项目</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/TypeClient/assets/js/app.253fc704.js" defer></script><script src="/TypeClient/assets/js/2.86eb2bce.js" defer></script><script src="/TypeClient/assets/js/7.d976a72a.js" defer></script>
  </body>
</html>
